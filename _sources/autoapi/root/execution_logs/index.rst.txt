root.execution_logs
===================

.. py:module:: root.execution_logs


Classes
-------

.. autoapisummary::

   root.execution_logs.ExecutionLogs
   root.execution_logs.ExecutionResult


Module Contents
---------------

.. py:class:: ExecutionLogs(client_context: root.utils.ClientContextCallable)

   Execution logs API


   .. py:method:: aget(*, log_id: Optional[str] = None, execution_result: Optional[ExecutionResult] = None, _request_timeout: Optional[int] = None, _client: root.generated.openapi_aclient.ApiClient) -> root.generated.openapi_aclient.models.execution_log_details.ExecutionLogDetails
      :async:


      Asynchronously get a specific execution log details

      :param log_id: The log to be fetched
      :param execution_result: The execution result containing the log ID.

      :raises ValueError: If both log_id and execution_result are None.



   .. py:method:: alist(*, limit: int = 100, search_term: Optional[str] = None, tags: Optional[List[str]] = None, include: Optional[List[str]] = None, _request_timeout: Optional[int] = None) -> AsyncIterator[root.generated.openapi_aclient.models.execution_log_list.ExecutionLogList]
      :async:


      Asynchronously list execution logs

      :param limit: Number of entries to iterate through at most.
      :param search_term: Can be used to limit returned logs. For example, a evaluator id or name.
      :param tags: Optional tags to filter the logs by.
      :param include: Optional fields to include in the response.



   .. py:method:: get(*, log_id: Optional[str] = None, execution_result: Optional[ExecutionResult] = None, _request_timeout: Optional[int] = None, _client: root.generated.openapi_client.ApiClient) -> root.generated.openapi_client.models.execution_log_details.ExecutionLogDetails

      Get a specific execution log details

      :param log_id: The log to be fetched
      :param execution_result: The execution result containing the log ID.

      :raises ValueError: If both log_id and execution_result are None.



   .. py:method:: list(*, limit: int = 100, search_term: Optional[str] = None, tags: Optional[List[str]] = None, include: Optional[List[str]] = None, _request_timeout: Optional[int] = None, _client: root.generated.openapi_client.ApiClient) -> Iterator[root.generated.openapi_client.models.execution_log_list.ExecutionLogList]

      List execution logs

      :param limit: Number of entries to iterate through at most.
      :param search_term: Can be used to limit returned logs. For example, a evaluator id or name.
      :param tags: Optional tags to filter the logs by.
      :param include: Optional fields to include in the response.



   .. py:attribute:: client_context


.. py:class:: ExecutionResult

   Bases: :py:obj:`Protocol`


   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing).

   For example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto(Protocol[T]):
           def meth(self) -> T:
               ...


   .. py:attribute:: execution_log_id
      :type:  str


